import type { Transaction } from '@bitauth/libauth';
import type { NetworkProvider } from './network/index.js';
import type SignatureTemplate from './SignatureTemplate.js';
export interface Utxo {
    txid: string;
    vout: number;
    satoshis: bigint;
    token?: TokenDetails;
}
export interface SignableUtxo extends Utxo {
    template: SignatureTemplate;
}
export declare function isSignableUtxo(utxo: Utxo): utxo is SignableUtxo;
export interface Recipient {
    to: string;
    amount: bigint;
    token?: TokenDetails;
}
export interface Output {
    to: string | Uint8Array;
    amount: bigint;
    token?: TokenDetails;
}
export interface TokenDetails {
    amount: bigint;
    category: string;
    nft?: {
        capability: 'none' | 'mutable' | 'minting';
        commitment: string;
    };
}
export interface NftObject {
    category: string;
    capability: 'none' | 'mutable' | 'minting';
    commitment: string;
}
export interface LibauthOutput {
    lockingBytecode: Uint8Array;
    valueSatoshis: bigint;
    token?: LibauthTokenDetails;
}
export interface LibauthTokenDetails {
    amount: bigint;
    category: Uint8Array;
    nft?: {
        capability: 'none' | 'mutable' | 'minting';
        commitment: Uint8Array;
    };
}
export declare enum SignatureAlgorithm {
    ECDSA = 0,
    SCHNORR = 1
}
export declare enum HashType {
    SIGHASH_ALL = 1,
    SIGHASH_NONE = 2,
    SIGHASH_SINGLE = 3,
    SIGHASH_UTXOS = 32,
    SIGHASH_ANYONECANPAY = 128
}
export declare const Network: {
    MAINNET: "mainnet";
    TESTNET3: "testnet3";
    TESTNET4: "testnet4";
    CHIPNET: "chipnet";
    REGTEST: "regtest";
};
export declare type Network = (typeof Network)[keyof typeof Network];
export interface TransactionDetails extends Transaction {
    txid: string;
    hex: string;
}
export interface ContractOptions {
    provider?: NetworkProvider;
    addressType?: 'p2sh20' | 'p2sh32';
}
